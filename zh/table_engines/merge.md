# Merge

Merge 引擎表（不要和 `MergeTree` 相混淆）本身并不存储数据，但是它可以同时地从任意其他表中读取数据。
Merge 引擎表的数据读取是并行的，但它不支持数据写入。当数据读取的时候，读取不同的表会使用它本身有的索引。
Merge 引擎支持一些参数：数据库名字和一个匹配表名称的正则表达式。示例：

```text
Merge(hits, '^WatchLog')
```

- 数据会从 `hits` 数据库中满足 `^WatchLog` 正则匹配的表中读取。

除了指定数据库名称，还可以使用常量表达式表示一个字符串来指定，比如说 `currentDatabase()`。

正则表达式是使用 re2 (与 PCRE 类似), 大小写敏感。
在 "(match)[../functions/string_search_functions#match-haystack-pattern]" 部分可以了解到正则表达式中转义符号的解释。

当选择匹配的表进行读取时，Merge 表本身是不会被选择的，即使它是满足正则匹配的，这样可以了防止表的循环读取。
可以创建两个 Merge 表且让其中一个表设置成读取另外一个表。但最好不要这样做。

使用 Merge 引擎最常见的场景是将大量的 TinyLog 表当做一个单表来读取。

## 虚拟列

虚拟列是指表引擎提供的列，而不管表是如何定义的。换句话说，这些列并没有在 CREATE TABLE 语句中指定，但是却可以被 SELECT。

虚拟列和普通列有以下不同：

- 它们不在表定义中指定。
- 不可以通过 INSERT 虚拟列来插入数据。
- 当没有指定列的字段来 INSERT 数据时，虚拟列是被忽略的。
- 使用星号来做选择查询时（`SELECT *`），虚拟列不会被选择。
- 虚拟列不会在 `SHOW CREATE TABLE` 和 `DESC TABLE` 查询中显示出来。

Merge 引擎表实际上是含有一个字符串格式的虚拟列 `_table`（若表中已经含有 `_table` 字段，虚拟列则命名为 `_table1`，若表中也有 `_table1`，则命名为 `_table2`，以此类推）。它包含了需要读取的表名称。 

如果 WHERE 或者 PREWHERE 子句中含有了 `_table` 字段的条件，且这些条件不依赖与其他表字段，则这些条件会被当做一个索引来使用。这些条件表明从一批数据集中读取数据时，读取的操作只会在条件触发的表中执行。
